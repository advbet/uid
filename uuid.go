package uid

import (
	"bytes"
	"crypto/rand"
	"crypto/sha1"
	"database/sql/driver"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"time"
)

const variantInts = 0x00     // 00xx xxxx
const variantTimeRand = 0x01 // 01xx xxxx
const variantRFC4122 = 0x02  // 10xx xxxx

// UUID type is used to store UUID in binary form
type UUID [16]byte

// Zero is a special UUID value with all bits set to 0. Because UUID type is
// an array (not a slice) it can be directly compared with Zero value without a
// loop. Example `if x == uid.Zero {}`.
var Zero = UUID{}

// NewInts generates a new custom format UUID from two 64 bit unsigned integers.
// Integers are written directly to UUID in network byte order (first integer in
// first eight octets, second in second eight). This type has a custom variant
// value 00xx xxxx to avoid collisions with RFC-4122 UUID variants.
//
// UUID generated by this function will have following layout:
//
//  0  1  2  3  4  5  6  7  8         9 10 11 12 13 14 15 16
//  |  |  |  |  |  |  |  |  |         |  |  |  |  |  |  |  |
//  |aa|aa|aa|aa|aa|aa|aa|aa|00bb bbbb|bb|bb|bb|bb|bb|bb|bb|
//
// Note: Two most significant bits from `b` will be overwriten by variant
// type.
func NewInts(a uint64, b uint64) (uuid UUID) {
	binary.BigEndian.PutUint64(uuid[:8], a)
	binary.BigEndian.PutUint64(uuid[8:], b)
	uuid.setVariant(variantInts)
	return
}

// ParseIntBased extracts two 64bit integer values from integer based UUID. This
// function also checks variant type and returns error if UUID variant type does
// not match integer based UUIDs.
func (uuid UUID) ParseIntBased() (a uint64, b uint64, err error) {
	if uuid.getVariant() != variantInts {
		return 0, 0, errors.New("UUID value is not integer based")
	}
	a = binary.BigEndian.Uint64(uuid[:8])
	b = binary.BigEndian.Uint64(uuid[8:])
	return
}

// NewTimeRand generates a new custom format UUID. This UUID is guaranteed to
// always increasing when generated on a single machine, provided that machine
// clock is not changed. This type has a custom variant value 001x xxxx to avoid
// collisions with RFC-4122 UUID variants.
//
// UUID generated by this function will have following layout:
//
//  0  1  2  3  4  5  6  7  8         9 10 11 12 13 14 15 16
//  |  |  |  |  |  |  |  |  |         |  |  |  |  |  |  |  |
//  |yy|yy|yy|yy|yy|yy|yy|yy|01xx xxxx|xx|xx|xx|xx|xx|xx|xx|
//
// First 8 octets (y value) will be set to current time in nanoseconds. First
// two bits of 8th octet will be set to 01 (custom variant) value. Remaining
// octets (x value) will be filled with random bits from the system entropy
// pool.
func NewTimeRand() (uuid UUID) {
	randPart := make([]byte, 8)
	timePart := time.Now().UnixNano()
	if _, e := rand.Read(randPart); e != nil {
		panic(e)
	}

	binary.BigEndian.PutUint64(uuid[:8], uint64(timePart))
	copy(uuid[8:], randPart)
	uuid.setVariant(variantTimeRand)

	return uuid
}

// NewV5 creates new UUID based on SHA-1 hash of namespace UUID and name as
// defined in RFC4122 (Section-4.3. Algorithm for Creating a Name-Based UUID).
func NewV5(ns UUID, name string) (uuid UUID) {
	h := sha1.New()

	h.Write(ns[:])
	h.Write([]byte(name))
	copy(uuid[:], h.Sum(nil))

	uuid.setVersion(5)
	uuid.setVariant(variantRFC4122)

	return uuid
}

// Parse creates new UUID from string. It is a convenience function to perform
// UUID allocation and call to UnmarshalText in one line.
func Parse(str string) (uuid UUID, err error) {
	err = uuid.UnmarshalText([]byte(str))
	return
}

// setVariant updates two bits of variant identifier as described in
// RFC4122 (Section 4.1.1. Variant).
//
// Only two least significant bits of `variant` is used.
func (uuid *UUID) setVariant(variant byte) {
	// x x x x x x x x   uuid[8]
	// 0 0 1 1 1 1 1 1   0x3f

	// y y y y y y y y   variant
	// 0 0 0 0 0 0 1 1   0x03

	uuid[8] = (uuid[8] & 0x3f) | (variant << 6)
}

// getVariant returns variant identifier - two most significant bits of 8-th
// octet.
func (uuid *UUID) getVariant() byte {
	return uuid[8] >> 6
}

// setVersion sets version bits.
func (uuid *UUID) setVersion(version byte) {
	uuid[6] = (uuid[6] & 0x0f) | (version << 4)
}

// String converts UUID to canonical UUID string representation.
func (uuid UUID) String() string {
	return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:16])
}

// Scan implements Scanner interface from database/sql package.
func (uuid *UUID) Scan(src interface{}) error {
	switch src := src.(type) {
	case []byte:
		if len(src) != len(uuid) {
			return errors.New("Incompatible underlying DB type length, UUID must be exactly 16 bytes")
		}
		for i := range src {
			uuid[i] = src[i]
		}
	default:
		return fmt.Errorf("Cannot convert %T to UUID, only []byte is supported", src)
	}
	return nil
}

// Value implements Valuer interface from database/sql/driver package.
func (uuid UUID) Value() (driver.Value, error) {
	return []byte(uuid[:]), nil
}

// MarshalText implements TextMarshaler interface from encoding package.
func (uuid UUID) MarshalText() ([]byte, error) {
	return []byte(uuid.String()), nil
}

// UnmarshalText implements TextUnmarshaler inferface from encoding package.
func (uuid *UUID) UnmarshalText(data []byte) error {
	// Remove - symbols
	data = bytes.Replace(data, []byte{'-'}, nil, -1)
	if len(data) != 2*len(uuid) {
		return errors.New("UUID value must have 32 hexadecimal symbols")
	}
	_, err := hex.Decode(uuid[:], data)
	return err
}
